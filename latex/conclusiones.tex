\chapter{Conclusiones y trabajo a futuro}\label{chap:conclusiones}
Los resultados obtenidos durante la experimentación muestran en general un buen comportamiento del tracking en profundidad. Logramos obtener buenos porcentajes promedio de solapamiento y una buena frecuencia de seguimiento con poca información sobre el objeto a seguir sin regisrar falsos positivos en casi la totalidad de las pruebas realizadas. Además, el método se adapta bien a las distintas formas de los objetos, aunque puede reportar malos resultados si el objeto a buscar es muy pequeño, está alejado del sensor RGB-D o si la nube de puntos del modelo del objeto es plana. Este es el caso de la caja y de la lata cuyos modelos son planos o con forma poco definida y son los casos en donde el sistema se comportó peor.

El sistema RGB-D que presentamos posee un tracking robusto, el cual presenta una tasa de falsos positivos muy baja. Sin embargo, los métodos de detección elegidos no son lo suficientemente buenos para que el sistema se destaque por completo.

La combinación de métodos RGB y de profundidad para el seguimiento mejora la efectividad y robustez del seguimiento. Sin embargo, resulta de vital importancia combinar los métodos de manera de maximizar las ventajas de cada uno. Sería conveniente encontrar alguna manera de comparar el resultado obtenido con el método de profundidad y el obtenido al tratar de corregir este resultado con el método RGB. De esta manera se podría cuantificar la mejora otorgada por el seguimiento secundario y reportar el mejor de los dos resultados, tratando de afectar lo menos posible al resultado final.

Para un mejor funcionamiento del sistema de seguimiento en general, es de vital importancia contar con un método de detección robusto y eficaz. Los resultados obtenidos para nuestro sistema son buenos para la mayoría de los casos analizados pero si se los contrasta con los obtenidos con el método de detección ideal todos los valores analizados están muy por debajo de lo mejor que se puede obtener del método de seguimiento combinado propuesto. Esto se debe a la importancia que tiene la etapa de detección en el sistema, la cual no fue objetivo de esta tesis. Una tarea a futuro es adaptar el trabajo realizado en \cite{hinterstoisser2010dominant} en nuestro sistema ya que combina una robusta y precisa detección con una performance de tiempo real.

Nuestro sistema de seguimiento tiene varias mejoras posibles para implementar. Una de ellas es hacer que el método de seguimiento sea robusto a oclusiones. Como se muestra en la Figura \ref{taza_ocluida} el método de seguimiento funciona correctamente pero solo reporta el área de la parte visible del objeto que se sigue, haciendo que el porcentaje de solapamiento con el área reportada por el ground truth sea menor al 50\%. Esto se puede resolver utilizando el filtro de Kalman \cite{welch1995introduction} adaptándolo al dominio 3D que utilizamos. El filtro de Kalman es un filtro muy popular y estudiado extensivamente en la literatura \cite{julier1997new,wan2000unscented} debido a su gran desempeño para realizar seguimiento en imágenes 2D.

Una decisión que tomamos al implementar el método de seguimiento en profundidad fue la de filtar luego de cada seguimiento exitoso los puntos de la escena correspondientes al objeto buscado. Esta tarea no es sencilla y la precisión del resultado varía frame a frame. A pesar de los intentos por adaptar nuestro filtro a estos cambios, por ejemplo, cambiando el radio máximo de búsqueda de vecinos cercanos para el \kdt (ver Sección \ref{deteccion_d}), muchas veces sucede que se incluyen puntos que no corresponden al objeto buscado. Por esta razón, no siempre es conveniente filtrar los puntos de la escena. Si el modelo del objeto es lo suficientemente completo las alineaciones van a ser buenas y constantes a pesar de que la pose del objeto en la escena varíe. Sin embargo el filtro es de mucha utilidad si el modelo del objeto es muy incompleto ya que se le da la posibilidad al método de seguir al objeto incluso cuando la vista del frame sea completamente distinta al modelo del objeto.

Otra mejora a explorar está relacionada con la manera que comparamos histogramas RGB. Durante la etapa de búsqueda de valores de parámetros definimos un umbral máximo para la diferencia arrojada por la comparación de Bhattachayyra (ver Sección \ref{tracking_rgb}). Sin embargo este umbral sería mejor si se adaptara automáticamente según el tamaño, forma del objeto y color de fondo de la imagen. El resultado otorgado por el algoritmo tiene entre otras cosas las coordenadas en el dominio 2D de la imagen RGB de un cuadrante que contiene al objeto seguido. Dependiendo de la forma del objeto este cuadrante va a contener más o menos área que no sea parte del objeto sino de lo que existe alrededor del mismo. Si el fondo del objeto va cambiando durante la escena, el cálculo del histograma se ve afectado por este cambio y por lo tanto también lo va a hacer el resultado de la comparación con el histograma del template del objeto. Si a esto le agregamos que la forma del objeto es tal que el área que ocupa en el recuadro que lo contiene es pequeña, la diferencia de histogramas va a ser mayor aún ante cambios en el fondo de la imagen. Este problema provoca que se descarten buenos resultados al tener un umbral fijo.

Para obtener un sistema de seguimiento completamente automático hace falta implementar un algoritmo de segmentación de objetos en imágenes 3D para la etapa de entrenamiento, cuyo funcionamiento sea similar a lo hecho en el trabajo de Lepetit et al. \cite{park2011texture}. De esta manera se puede obtener una buena vista del objeto en 3D que sirva como modelo para el seguimiento en profundidad, a la vez que se toma la información en RGB para el seguimiento en 2D.

Como trabajo a futuro queda implementar todas estas técnicas de manera eficiente para lograr un seguimiento en tiempo real. Durante el desarrollo de este trabajo se tomaron recaudos en generar un código fuente que permitiera cambios rápidos para probar distintos métodos, ya sea de seguimiento, de detección, de entrenamiento, distintas variantes al esquema de seguimiento propuesto y combinaciones de los métodos en cada una de las etapas, pero en ningún momento se priorizó la performance por la claridad en el código. Tener una implementación que funcione en tiempo real sería de vital importancia si se quisiera usar este método en alguna aplicación real.
